 

> 先入门课程，后判定是否学习提高课，最后整理成个人笔记

## 为什么选择 Go 语言？

### Go 语言的优势

> 思考角度：复杂度、资源消耗、性能...

1. （业界公认）对初学者友善，可以**快速上手**：作为静态编程语言的 Go 已经将入门门槛，降低到和动态语言一个水平线上
   - 补充问题：区分静态编程语言和动态编程语言

2. 是**生产力与性能的最佳结合**
   - 对比静态语言：满足“构建流行的、高性能的服务器端编程语言”的需求，在带有 GC 和运行时的语言中性能名列前茅，与不带 GC 的静态语言（C/CPP）之间也没有数量级差距
   - 对比动态语言：保持生产力的同时，大幅度提高性能
   - 补充问题：静态语言带有 GC 和运行时的优劣

### 如何学习 Go 语言

1. 对语言认真评估：避免盲目入坑导致沉没的时间和精力成本
2. 多动手，培养独属于 Go 的编程思维方式

3. 建立设计意识：培养选择适当的语言元素构造程序骨架的能力

<br>

## Go 语言设计哲学

> 总结：简单，显式，组合，并发，面向工程

### 简单

> Golang 中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素

1.  仅有 25 个关键字
2. 内置垃圾回收，降低开发人员内存管理的心智负担
3. 首字母大小写决定可见性
4. 变量初始为类型零值，避免随机初始值
5. 内置数组边界检查，减少越界访问带来的安全隐患
6. 内置并发支持
7. 内置接口类型...

### 显式

> Go 中不同类型变量是不能在一起进行混合计算的（开发人员明确知道自己在做什么）

```go
// Go 不允许不同类型的整型变量进行混合计算，即不会对其进行隐式的自动转换
var a int16 = 5
var b int = 8
var c int64

c = a + b

fmt.Printf("%d\n", c)	// invalid operation: a + b (mismatched types int16 and int)


// 需要显式转换
c = int64(a) + int64(b)
fmt.Printf("%d\n", c)
```

> Go 采用了显式的基于值比较的错误处理方案

函数/方法中的错误都会通过`return`语句显式地返回，并且通常调用者不能忽略对返回错位的处理

### 组合

> Go 推崇**组合**，而非经典的面向对象语法元素、类型体系、继承机制

- 无类型层次体系，各类型是相互独立的，没有子类型的概念
- 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的
- 提供接口类型
- 包之间相对独立，没有子包的概念

- 为支撑组合提供**类型嵌入 Type Embedding**，将已实现的功能嵌入到新类型中，实现功能复用
  - 被嵌入的类型与新类型无关，方法匹配取决于名字而非类型，即垂直组合

<br>

**垂直组合**（类型层面）：理解为“能力继承”，采用嵌入方式定义的新类型继承了嵌入类型的能力

```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}   
    shared  []interface{}
    Mutex               
    pad     [128]byte  
}
```

直接在`poolLocal`结构体中嵌入类型`Mutex`，使其具有互斥同步的能力

```go
// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

标准库通过嵌入接口类型的方式实习接口行为的聚合，组成大接口

**水平组合**（方法层面）：是一种能力委托，通常使用接口类型实现

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

`ReadAll`通过`io.Reader`接口，将`io.Reader`的实现与`ReadAll`所在的包低耦合地水平组合在一起，从而可以从任意实现`io.Reader`的数据源读取所有数据的目的

### 并发

> Go 以面向多核、原生支持并发为原则，放弃传统基于操作系统线程的并发模型，采用了用户层轻量级线程 goroutine

- goroutine 调度的切换不用陷入 trap 操作系统内核层完成，代价小
- 提供`channel`传递消息或实现同步，通过`select`实现多路`channel`并发控制，即原生支持并发

goroutines 各自执行功能特定的工作，并通过`channel + select`组合连接起来

### 面向工程

> Go 设计的初衷：面向解决真实世界中 Google 内部大规模软件开发存在的各自问题，为这些问题提供答案
>
> 问题：程序构建慢、依赖管理失控、代码难以理解、跨语言构建难...











